例如：abacda

方法一:维护数组
  1、遍历字符串，判断数组中是否包含该字符
  2、如果不包含，将该字符添加到数组
  3、如果包含（说明重复），前面重复的元素连同之前的元素一起删掉
  4、在每次数组添加元素之后去更新maxLength最大长度

  案例说明：
  [a]-[ab]-[aba]重复，删除前一个a-[ba]-[bac]-[bacd]-[bacda]重复，删掉ba-[cda]

  小知识点：
  1、字符串是有length属性的，可以通过s[索引]访问
  2、判断数组中是否具有某个元素----数组.indexOf()方法。不包含返回-1.包含返回对应元素索引号
  3、删除数组的某些元素----数组.splice(index,count)。index表示从哪个索引开始删除，count为删除的数量

方法二:双指针+哈希表（其实和方法1的原理相同）
  1、利用左右指针构建一个滑动窗口
  2、右侧指针依次向右移动，将读取的元素值作为哈希表的index，索引作为value保存
  3、如果哈表中存在右指针指定的元素（说明重复），那么令左指针指向重复元素的右侧一位（这里和方法一其实是一样的，都是变相的删掉了重复元素和重复元素之前的值）
     问题：为什么程序中的i要取原先的i和哈希表中重复的索引号+1的最大值（这种情况出现在abba这种，先出的元素后重复，会导致b重复之后，在a重复时哈希表中记录的a的索引小于左侧指针，这就仍需要使用原先的左侧指针而不是a的索引+1）
     为什么？ 例如abba，当b重复时后，i为第二个b的索引2，当前字符串为b。但是当第二个a出现时，哈希表中记录的a的索引为0，当前字符串为ba并没有出现重复，如仍使用哈希表中存放的a的索引0，显然是不对的（因为此刻并没有重复，不需要动左侧指针），这时候是不需要动左侧指针的，仍使用原先的左侧指针。所以左侧指针使用的是原左侧指针指向元素的索引和哈希表中存放的重复元素索引中较大的那方。

  4、不管是右指针移动还是左指针移动，都要更新一下maxLength
  5、问题：如果没有重复，那么要将右指针的值存入哈希表，如果重复，在左指针移动之后，也要用新的重复值去更新哈希表中原先存放的值
     为什么？ 比如abacad这种，当第一次a重复时，哈希表中存放的是第一个a的索引0，如果不用最新的a的索引3去做更新，那么下次a再出现的时候，在哈希表中搜索到的仍旧是第一个a的索引0，这明显是错误的，因为需要的是第二个a的索引。
  
  小知识点：1、js中创建哈希表：map = new Map。2、查找 map.get(index)，返回值是value。3、判断是否有某个index：map.has(index)返回值是布尔值。4、存放：map.set(index,value)
          2、字符串转数组：数组.split(分割符). 数组转字符串：字符串.join(连接符)
          3、charAt：字符串.charAt(索引)，和字符串[索引]一样的效果

比较：方法1时间复杂度O(n2).方法2时间复杂度O(n). 因为数组.indexOf时间复杂度为n。而map.has为1
